import {
  InstagramAccount,
  InsertInstagramAccount,
  ScheduledContent,
  InsertScheduledContent,
  instagramAccounts,
  scheduledContent
} from "@shared/schema";
import { db } from "./db";
import { eq, and } from "drizzle-orm";
import session from "express-session";
import connectPg from "connect-pg-simple";
import { Pool } from "pg";

export interface IStorage {
  // Instagram Account Operations
  createInstagramAccount(account: InsertInstagramAccount): Promise<InstagramAccount>;
  getInstagramAccount(id: number): Promise<InstagramAccount | undefined>;
  getInstagramAccountByUsername(username: string): Promise<InstagramAccount | undefined>;
  getAllInstagramAccounts(): Promise<InstagramAccount[]>;
  updateInstagramAccount(id: number, data: Partial<InsertInstagramAccount>): Promise<InstagramAccount | undefined>;
  deleteInstagramAccount(id: number): Promise<boolean>;
  
  // Scheduled Content Operations
  createScheduledContent(content: InsertScheduledContent): Promise<ScheduledContent>;
  getScheduledContent(id: number): Promise<ScheduledContent | undefined>;
  getAllScheduledContent(): Promise<ScheduledContent[]>;
  updateScheduledContent(id: number, data: Partial<InsertScheduledContent>): Promise<ScheduledContent | undefined>;
  deleteScheduledContent(id: number): Promise<boolean>;
  
  // Session support
  sessionStore: session.Store;
}

export class DatabaseStorage implements IStorage {
  sessionStore: session.Store;
  
  constructor() {
    const PostgresStore = connectPg(session);
    const pool = new Pool({ connectionString: process.env.DATABASE_URL });
    
    this.sessionStore = new PostgresStore({
      pool,
      createTableIfMissing: true,
    });
  }
  
  // Instagram Account Operations
  async createInstagramAccount(account: InsertInstagramAccount): Promise<InstagramAccount> {
    const [newAccount] = await db
      .insert(instagramAccounts)
      .values(account)
      .returning();
    
    return newAccount;
  }
  
  async getInstagramAccount(id: number): Promise<InstagramAccount | undefined> {
    const [account] = await db
      .select()
      .from(instagramAccounts)
      .where(eq(instagramAccounts.id, id));
    
    return account;
  }
  
  async getInstagramAccountByUsername(username: string): Promise<InstagramAccount | undefined> {
    const [account] = await db
      .select()
      .from(instagramAccounts)
      .where(eq(instagramAccounts.username, username));
    
    return account;
  }
  
  async getAllInstagramAccounts(): Promise<InstagramAccount[]> {
    return await db
      .select()
      .from(instagramAccounts);
  }
  
  async updateInstagramAccount(id: number, data: Partial<InsertInstagramAccount>): Promise<InstagramAccount | undefined> {
    const [updatedAccount] = await db
      .update(instagramAccounts)
      .set(data)
      .where(eq(instagramAccounts.id, id))
      .returning();
    
    return updatedAccount;
  }
  
  async deleteInstagramAccount(id: number): Promise<boolean> {
    const result = await db
      .delete(instagramAccounts)
      .where(eq(instagramAccounts.id, id));
    
    return true; // PostgreSQL doesn't return boolean for delete operations
  }
  
  // Scheduled Content Operations
  async createScheduledContent(content: InsertScheduledContent): Promise<ScheduledContent> {
    // Ensure all optional fields are properly handled
    const dataToInsert = {
      ...content,
      firstComment: content.firstComment || null,
      location: content.location || null,
      hideLikeCount: content.hideLikeCount === undefined ? false : content.hideLikeCount,
      taggedUsers: Array.isArray(content.taggedUsers) ? content.taggedUsers : null
    };
    
    const [newContent] = await db
      .insert(scheduledContent)
      .values(dataToInsert)
      .returning();
    
    return newContent;
  }
  
  async getScheduledContent(id: number): Promise<ScheduledContent | undefined> {
    const [content] = await db
      .select()
      .from(scheduledContent)
      .where(eq(scheduledContent.id, id));
    
    return content;
  }
  
  async getAllScheduledContent(): Promise<ScheduledContent[]> {
    return await db
      .select()
      .from(scheduledContent);
  }
  
  async updateScheduledContent(id: number, data: Partial<InsertScheduledContent>): Promise<ScheduledContent | undefined> {
    // Get the existing content first to ensure we handle nulls properly
    const [existingContent] = await db
      .select()
      .from(scheduledContent)
      .where(eq(scheduledContent.id, id));
    
    if (!existingContent) {
      return undefined;
    }
    
    // Prepare data with proper null handling
    const updatedData = {
      ...data,
      firstComment: data.firstComment !== undefined ? data.firstComment : existingContent.firstComment,
      location: data.location !== undefined ? data.location : existingContent.location,
      hideLikeCount: data.hideLikeCount !== undefined ? data.hideLikeCount : existingContent.hideLikeCount,
      taggedUsers: data.taggedUsers !== undefined ? 
        (Array.isArray(data.taggedUsers) ? data.taggedUsers : null) : 
        existingContent.taggedUsers
    };
    
    const [updatedContent] = await db
      .update(scheduledContent)
      .set(updatedData)
      .where(eq(scheduledContent.id, id))
      .returning();
    
    return updatedContent;
  }
  
  async deleteScheduledContent(id: number): Promise<boolean> {
    await db
      .delete(scheduledContent)
      .where(eq(scheduledContent.id, id));
    
    return true;
  }
}

// Memory storage implementation for fallback
export class MemStorage implements IStorage {
  private instagramAccounts: Map<number, InstagramAccount>;
  private scheduledContent: Map<number, ScheduledContent>;
  private accountId: number;
  private contentId: number;
  sessionStore: session.Store;
  
  constructor() {
    this.instagramAccounts = new Map();
    this.scheduledContent = new Map();
    this.accountId = 1;
    this.contentId = 1;
    
    const MemoryStore = require('memorystore')(session);
    this.sessionStore = new MemoryStore({
      checkPeriod: 86400000 // prune expired entries every 24h
    });
  }
  
  // Instagram Account Operations
  async createInstagramAccount(account: InsertInstagramAccount): Promise<InstagramAccount> {
    const id = this.accountId++;
    
    const newAccount: InstagramAccount = { 
      ...account, 
      id, 
      createdAt: new Date() 
    };
    
    this.instagramAccounts.set(id, newAccount);
    return newAccount;
  }
  
  async getInstagramAccount(id: number): Promise<InstagramAccount | undefined> {
    return this.instagramAccounts.get(id);
  }
  
  async getInstagramAccountByUsername(username: string): Promise<InstagramAccount | undefined> {
    for (const account of this.instagramAccounts.values()) {
      if (account.username === username) {
        return account;
      }
    }
    return undefined;
  }
  
  async getAllInstagramAccounts(): Promise<InstagramAccount[]> {
    return Array.from(this.instagramAccounts.values());
  }
  
  async updateInstagramAccount(id: number, data: Partial<InsertInstagramAccount>): Promise<InstagramAccount | undefined> {
    const account = this.instagramAccounts.get(id);
    if (!account) return undefined;
    
    const updatedAccount = { ...account, ...data };
    this.instagramAccounts.set(id, updatedAccount);
    return updatedAccount;
  }
  
  async deleteInstagramAccount(id: number): Promise<boolean> {
    return this.instagramAccounts.delete(id);
  }
  
  // Scheduled Content Operations
  async createScheduledContent(content: InsertScheduledContent): Promise<ScheduledContent> {
    const id = this.contentId++;
    
    // Ensure the content has proper types and null values for optional fields
    const newContent: ScheduledContent = { 
      ...content, 
      id, 
      createdAt: new Date(),
      // Set default status if not provided
      status: content.status || "scheduled",
      // Ensure null values for optional fields
      firstComment: content.firstComment || null,
      location: content.location || null,
      hideLikeCount: content.hideLikeCount === undefined ? false : content.hideLikeCount,
      taggedUsers: Array.isArray(content.taggedUsers) ? content.taggedUsers : null
    };
    
    this.scheduledContent.set(id, newContent);
    return newContent;
  }
  
  async getScheduledContent(id: number): Promise<ScheduledContent | undefined> {
    return this.scheduledContent.get(id);
  }
  
  async getAllScheduledContent(): Promise<ScheduledContent[]> {
    return Array.from(this.scheduledContent.values());
  }
  
  async updateScheduledContent(id: number, data: Partial<InsertScheduledContent>): Promise<ScheduledContent | undefined> {
    const content = this.scheduledContent.get(id);
    if (!content) return undefined;
    
    // Create the updated content with proper null handling
    const updatedContent: ScheduledContent = { 
      ...content, 
      ...data,
      // Ensure null values for optional fields if they're undefined
      firstComment: data.firstComment !== undefined ? data.firstComment : content.firstComment,
      location: data.location !== undefined ? data.location : content.location,
      hideLikeCount: data.hideLikeCount !== undefined ? data.hideLikeCount : content.hideLikeCount,
      taggedUsers: data.taggedUsers !== undefined ? 
        (Array.isArray(data.taggedUsers) ? data.taggedUsers : null) : 
        content.taggedUsers
    };
    
    this.scheduledContent.set(id, updatedContent);
    return updatedContent;
  }
  
  async deleteScheduledContent(id: number): Promise<boolean> {
    return this.scheduledContent.delete(id);
  }
}

// Export the appropriate storage implementation
export const storage = new DatabaseStorage();